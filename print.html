<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Basic-Golang 2021</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="day1.html"><strong aria-hidden="true">1.</strong> Day1</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="project/initial.html"><strong aria-hidden="true">1.1.</strong> Initial Go Project</a></li><li class="chapter-item expanded "><a href="project/simple.html"><strong aria-hidden="true">1.2.</strong> Go Simple Project</a></li><li class="chapter-item expanded "><a href="testing/SUMMARY.html"><strong aria-hidden="true">1.3.</strong> Testing in Golang</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="testing/testing.html"><strong aria-hidden="true">1.3.1.</strong> Create and Run Test</a></li><li class="chapter-item expanded "><a href="testing/naming.html"><strong aria-hidden="true">1.3.2.</strong> Naming and Convention</a></li><li class="chapter-item expanded "><a href="testing/benchmark.html"><strong aria-hidden="true">1.3.3.</strong> Benchmarking</a></li><li class="chapter-item expanded "><a href="testing/profile.html"><strong aria-hidden="true">1.3.4.</strong> Profiling</a></li><li class="chapter-item expanded "><a href="testing/sub.html"><strong aria-hidden="true">1.3.5.</strong> Sub Testing and Sub Benchmarking</a></li></ol></li><li class="chapter-item expanded "><a href="type/SUMMARY.html"><strong aria-hidden="true">1.4.</strong> Go Type</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="type/collection.html"><strong aria-hidden="true">1.4.1.</strong> Collection Type</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="type/array.html"><strong aria-hidden="true">1.4.1.1.</strong> Array</a></li><li class="chapter-item expanded "><a href="type/slice.html"><strong aria-hidden="true">1.4.1.2.</strong> Slice</a></li><li class="chapter-item expanded "><a href="type/map.html"><strong aria-hidden="true">1.4.1.3.</strong> Map</a></li></ol></li><li class="chapter-item expanded "><a href="type/struct/SUMMARY.html"><strong aria-hidden="true">1.4.2.</strong> Struct</a></li></ol></li><li class="chapter-item expanded "><a href="error/SUMMARY.html"><strong aria-hidden="true">1.5.</strong> Error and Defer</a></li></ol></li><li class="chapter-item expanded "><a href="day2.html"><strong aria-hidden="true">2.</strong> Day2</a></li><li class="chapter-item expanded "><a href="system/SUMMARY.html"><strong aria-hidden="true">3.</strong> System</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Basic-Golang 2021</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#day-1" id="day-1">Day 1</a></h1>
<h2><a class="header" href="#backlog-of-content" id="backlog-of-content">Backlog of Content</a></h2>
<p>List ของ git log จากทีี่ลองทำตามใน Class</p>
<pre><code class="language-text">174a278 [Added]: Interface of All
e00f4ce [Added]: Interface of Primitive Type Int
6b22fcd [Added]: Interface of Stringer
f876801 [Removed]: Stringer Interface
8b92209 [Added]: JSON Example and Exercise for add and list user
32731ca [Reorganized]: Folder Structure and move all of workshop into day1
4f7d6f4 [Init]: New task module for homework
73ee837 [Moved]: input.json into execise for initial data file
cef04a1 [Added]: Initial Cli with method NumberOfMember and AddMember
648726e [Added]: feature getMember with id
f5534c7 [Refactor]: Test to compare object instead of primitive
cd06b4a [Added]: Reviews Session of Day2
a97828c [Added]: Dependency Test of Store in UserService
9a078c5 [Added]: go module and sub module in go project
2f93cf4 [Added]: Version of Library
b72de03 [Added]: Project Structure
545a459 [Added]: Section2 SubPackage to call to Section1 SubPackage
32bbc90 [Added]: additional Go Project Structure
b40e03c [Added]: Content for Building RESTFul APIs
8310af8 [Added]: อธิบายการทำงานของ Router และ Middleware
</code></pre>
<h1><a class="header" href="#initial-go-project" id="initial-go-project">Initial Go Project</a></h1>
<pre><code class="language-cmd">$go mod init demo
</code></pre>
<p>จะได้ file ชื่อ go.mod มาใน folder</p>
<pre><code class="language-go">module demo

go 1.15
</code></pre>
<h1><a class="header" href="#go-simple-project" id="go-simple-project">Go Simple Project</a></h1>
<h2><a class="header" href="#create-demogo" id="create-demogo">Create demo.go</a></h2>
<p>สร้างไฟล์ demo.go (ชื่อเดียวกับ module) ปกติคนที่เขียน go จะมีการจัดการ module และจะสร้าง file ที่ชื่อเดียวกับ module ขึ้นมา เพื่อเป็นจุดเริ่มต้นของ module นั้น ซึ่งไม่จำเป็นต้องมีก็ได้ โดย File นี้ปกติจะไม่ถูกใช้ในการรัน</p>
<pre><code class="language-go">package demo    // กำหนดชื่อ package ให้เหมือนชื่อ module ที่ initial มา

func Greeting() string {  // ประกาศ Function ชื่อ Greeting โดยมี Return Type เป็น String
    return &quot;Hello World&quot;
}
</code></pre>
<h2><a class="header" href="#ขอกำหนดเรือง-function-name" id="ขอกำหนดเรือง-function-name">ข้อกำหนดเรื่อง Function Name</a></h2>
<p>เนื่องจาก Go มีข้อกำหนด เรื่อง Access Modifier ของแต่ละ Function โดยที่ Function ใดที่ต้องการให้ Access จากภายนอก Package ก็จะต้องขึ้นต้นด้วยตัวพิมพ์ใหญ่ เช่น ในกรณีนี้ Greeting สามารถเข้าถึง/เรียกใช้ได้จาก Package อื่น ๆ ถ้าเปลี่ยนเป็น greeting ก็จะเรียกใช้ไม่ได้</p>
<h2><a class="header" href="#create-maingo" id="create-maingo">Create main.go</a></h2>
<p>สร้าง Folder cmd ขึ้นมาเพื่อรองรับการ execute จาก cmd และสร้าง file ชื่อว่า main.go ขึ้นมา</p>
<pre><code class="language-go">package main    // package สำหรับ main.go จะเป็น main เสมอ

import &quot;demo&quot;   // ต้องการใช้ Func Greeting() จาก module demo จึงต้อง import package demo เข้ามา 

func main() {
    demo.Greeting()  // เรียกใช้ Greeting ที่อยู่ใน package demo
}
</code></pre>
<p>เนื่องจาก Package demo มีการกำหนด Function Greeting โดยที่มีตัวอักษรแรกเป็นตัวใหญ่ เลยสามารถเรียกใช้จาก Function main() ซึ่งอยู่ใน Package main  และเป็นคนละ Package  กับ Greeting ได้</p>
<p>ถ้าเราเปลี่ยน Greeting เป็น greeting ตอน Compile go ก็จะด่าเรา</p>
<h2><a class="header" href="#simple-project-structure" id="simple-project-structure">Simple Project Structure</a></h2>
<pre><code class="language-tree">demo
|- go.mod   // Package dependency for go project
|- demo.go  // Default go file for each module
|- cmd
    |- main.go   // runable file with main function
</code></pre>
<h1><a class="header" href="#testing-in-golang" id="testing-in-golang">Testing in Golang</a></h1>
<ul>
<li><a href="testing/./testing.html">Create and Run Test</a></li>
<li><a href="testing/./naming.html">Naming and Convention</a></li>
<li><a href="testing/./benchmark.html">Benchmarking</a></li>
<li><a href="testing/./profile.html">Profiling</a></li>
<li><a href="testing/./sub.html">Sub Testing and Sub Benchmarking</a></li>
</ul>
<h1><a class="header" href="#create-and-run-test" id="create-and-run-test">Create and Run Test</a></h1>
<h2><a class="header" href="#create-unit-test" id="create-unit-test">Create Unit Test</a></h2>
<p>ลักษณะของ File Test ใน Go</p>
<ul>
<li>อยู่ที่เดียวกับ Production Code</li>
<li>ใช้ชื่อ Package เดียวกัน ตามด้วย _test</li>
<li>Function Test ต้องขึ้นต้นด้วยคำว่า &quot;Test&quot; เสมอ</li>
<li>ภาษา Go แบบ Pure ๆ ต้องเขียนเช็คเงื่อนไขเอง</li>
</ul>
<p>ตย. demo_test.go</p>
<pre><code class="language-go">package demo_test   // ใช้ชื่อ Package เดียวกับ Production Code ตามด้วย _test
                    // ปกติถ้าชื่อ package ไม่ตรงกับ go.mod ตัว Compile go ก็จะด่ายกเว้นเป็นกรณีของ test

import (
    &quot;demo&quot;          // ต้องทำการ Import จาก Production Code เพื่อจำลองว่าถูกเรียกจาก นอก Package ของ Production
    &quot;testing&quot;       
)

func TestHello(t *testing.T) {      // Function Test ขึ้นต้นด้วย Test เสมอ
                                    // Test Framework  จะส่ง testing.T มาให้เราใช้
    var r string                    // ประกาศตัวแปลของ Go ซึ่งแาจจะใช้ r := demo.Greeting() ได้
    r = demo.Greeting()
    if r != &quot;Hello World&quot; {             // ต้องตรวจสอบ Result เองว่า Expected กับ Actual เท่ากันไหม
        t.Errorf(&quot;Error with %v&quot;, r)    // ใช้ t ที่ได้มาจัด Format ของ Error เวลา Test ไม่ผ่าน
    }
}
</code></pre>
<h2><a class="header" href="#การรัน-test" id="การรัน-test">การรัน Test</a></h2>
<p>การรัน Test ใช้ Command</p>
<pre><code class="language-cmd">$go test    // มันจะหาไฟล์ Testให้
</code></pre>
<p>ต้องการรัน Test ทั้งหมด ใน Sub-Folder</p>
<pre><code class="language-cmd">$go test ./...

ok    demo    (cached)              // ขึ้นคำว่า cached แปลว่า เคยรันแล้ว จะรันใหม่ก็ต่อเมื่อ Production Code เปลี่ยน
?     demo/cmd   [no test files]    // แจ้งว่าไม่มี File test
</code></pre>
<p>เราสามารถเช็ค Coverage ของเทสที่เราเขียนได้โดยการรัน</p>
<pre><code class="language-cmd">$go test -cover

PASS
coverage: 10.0% of statements
ok    demo    0.339s
</code></pre>
<p>หรือเราสามารถให้เก็บเป็น File ได้</p>
<pre><code class="language-cmd">$go test -coverprofile=coverage.out

PASS
coverage: 10.0% of statements
ok      demo    0.228s
</code></pre>
<p>ซึ่งจะได้ผลลัพท์เก็บใน File coverage.out</p>
<pre><code class="language-text">mode: set
demo/demo.go:3.24,5.2 1 1
</code></pre>
<p>หรือถ้าเราอยากเห็น Report สวยงาม แถมบอกด้วยว่าบรรทัดไหนผ่านการเทสไหม ก็สามารถใช้</p>
<pre><code class="language-cmd">go tool cover -html=coverage.out
</code></pre>
<p>มันจะเปิด Browser ขึ้นมาพร้อม coverage report เลย</p>
<h2><a class="header" href="#reference" id="reference">Reference</a></h2>
<ul>
<li><a href="https://golang.org/pkg/testing/">Go Testing Package</a></li>
</ul>
<h1><a class="header" href="#naming-and-convention" id="naming-and-convention">Naming and Convention</a></h1>
<h2><a class="header" href="#package-name-กับการทดสอบในภาษา-go" id="package-name-กับการทดสอบในภาษา-go">Package Name กับการทดสอบในภาษา Go</a></h2>
<p>เมื่อวันก่อนผมมีเขียนเกี่ยวกับเรื่อง <a href="https://sck.pub/basic-go-day1-1">Basic Golang</a> ตามที่ได้แอบฟังในคลาสพี่ปุ๋ยไป พอดีมีเวลา อยากทำความเข้าใจเรื่องการใน Go ดู ก็เลยลองเขียนฟังก์ชั่นง่าย ๆ เพื่อจะลองทดสอบดู ก่อนที่จะไปลองแบบยาก ๆ กลายเป็นว่า มันทำยังไงก็รันไม่ได้ แถม VS Code เจ้ากรรม พอเราจะลองอะไรบางอย่าง Extension ที่ลงไว้ก็ฉลาดซะอีก มาลบ Code ที่ลอง เพราะน่าจะผิดไวยากรณ์หรืออะไรสักอย่างของ Go เลยทำให้ผมรู้ตัวว่าตัวผมเองยังไม่เข้าใจใน ภาษา Go อยู่มากทีเดียว ยิ่งไปเจอใส่แค่เขียนเทสง่าย ๆ ให้รันได้ตามที่เราคิดยังทำไม่ได้เลย อย่าพึ่งไปไกลเลย วันนี้เลยจะกลับมาที่พื้นฐานเรื่องการทดสอบใน Go เพื่อให้ตัวเองเข้าใจมันก่อนดีกว่า พอได้ลองเล่นสักพักเลยคิดว่างั้นขอจดไว้สักหน่อยแล้วกัน เผื่อวันหลังต้องใช้จะได้มีที่ไว้ให้กลับมาอ่าน</p>
<h3><a class="header" href="#ตกมาตายตังแตแรกเลย" id="ตกมาตายตังแตแรกเลย">ตกม้าตายตั้งแต่แรกเลย</a></h3>
<p>จากที่ผมอธิบายไปใน Blog ก่อนหน้านี้ว่า ลักษณะของการเขียนการทดสอบใน Go มีหลักการคร่าว ๆ อยู่ 4 ข้อคือ อยู่ที่เดียวกับ Code, ให้ Package ต่อท้ายด้วย _test, ให้ชื่อฟังก์ชั่นขึ้นต้นด้วย Test และสุดท้ายต้องเขียนเงื่อนไขการทดสอบเอง ผมจึงลองเขียนเทสเล็ก ๆ ง่าย ๆ ตามนี้ดู</p>
<p><code>plus.go</code></p>
<pre><code class="language-go">package calculator

func Plus(input1 int, input2 int) int {
  return input1 + input2
}
</code></pre>
<p><code>plus_test.go</code></p>
<pre><code class="language-go">package calculator_test

import (
  &quot;testing&quot;
)

func Test1Plus1ShouldBe2Test(t *testing.T) {
  actual := Plus(1, 1)
  if 2 != actual {
    t.Errorf(&quot;1 + 1 should be 2 it's not %v&quot;, actual)
  }
}
</code></pre>
<p>ซึ่งกลายเป็นว่า Code นี้ Error เพราะ ไฟล์ Test (plus_test.go) ไม่สามารถเรียกใช้ ฟังก์ชั่น Plus ที่เขียนไว้ใน plus.go ได้ มาถึงแค่ตรงนี้ผมก็เริ่มมึนหล่ะ ทำไมมันเรียกใช้ไม่ได้หล่ะ ในเมื่อผมก็เขียนทุกอย่างถูกต้องตามที่ผมคิดแล้ว (สำหรับคนที่รู้แล้วอย่าพึ่ด่าผมเลยนะครับ ตอนนั้นมันหน้ามืดตามัวมาก) ซึ่ง VSCode มันก็บอกผมนะครับ ว่า</p>
<p><code>“undeclared name: Plus compiler”</code></p>
<p>ด้วยความไม่มั่นใจว่าเราทำอะไรบางอย่างผิดหรือเปล่า (มันต้องมีอะไรผิดแหละ) ผมเลยลองมั่ว ๆ ไปหลาย ๆ อย่าง</p>
<h3><a class="header" href="#ลองเปลียน-package-name-ดู" id="ลองเปลียน-package-name-ดู">ลองเปลี่ยน Package Name ดู</a></h3>
<p>อันแรกเลยเนื่องจากผมไม่ค่อยมั่นใจว่าเกิดอะไรขึ้น ผมเลยลองเปลี่ยนชื่อ Package ของ calculate_test กลับมาเป็น calculator เฉย ๆ มันก็รันเทสผ่านซะงั้น ถึงแม้ว่า Code จะผ่าน แต่ VS Code ก็ยังด่าผมในไฟล์ Test อยู่ดีว่า</p>
<p><code>plus.go</code></p>
<pre><code class="language-go">package calculator

func Plus(input1 int, input2 int) int {
  return input1 + input2
}
</code></pre>
<p><code>plus_test.go</code></p>
<pre><code class="language-go">package calculator

import (
  &quot;testing&quot;
)

func Test1Plus1ShouldBe2Test(t *testing.T) {
  actual := Plus(1, 1)
  if 2 != actual {
    t.Errorf(&quot;1 + 1 should be 2 it's not %v&quot;, actual)
  }
}
</code></pre>
<p><code>“package calculator; expected calculator_test compiler”</code></p>
<p>ซึ่งแปลว่ามันมองว่าไฟล์ Test (ชื่อไฟล์ plus_test.go) ก็ควรอยู่ใน Package calculator_test สิ (ตามที่เขียนไปตอนแรก)</p>
<h3><a class="header" href="#ลองใสชือ-package-ใน-import-ดู" id="ลองใสชือ-package-ใน-import-ดู">ลองใส่ชื่อ Package ใน Import ดู</a></h3>
<p>อันที่สองผมลองแบบทื่อ ๆ เลย คือในเมื่อมันต้องเป็น package ที่ตามด้วย _test แล้วจะไปใช้ฟังก์ชัน Plus ใน calculator ใช่ไหม งั้นก็ Force ใส่ใน import เนี่ยเลย กลายเป็นว่าพอสั่ง Save เท่านั้นแหละ VS Code ก็จัดการลบบรรทัดที่เพิ่มเข้าไปทิ้งซะเลย (ไอ้เราก็ดื้อ เอากลับมาแล้ว Save ใหม่อยู่สัก 2–3 รอบ VS Code ก็ยังลบให้อยู่ดี)</p>
<p><code>plus.go</code></p>
<pre><code class="language-go">package calculator

func Plus(input1 int, input2 int) int {
  return input1 + input2
}
</code></pre>
<p><code>plus_test.go</code></p>
<pre><code class="language-go">package calculator_test

import (
  &quot;calculator&quot;
  &quot;testing&quot;
)

func Test1Plus1ShouldBe2Test(t *testing.T) {
  actual := Plus(1, 1)
  if 2 != actual {
    t.Errorf(&quot;1 + 1 should be 2 it's not %v&quot;, actual)
  }
}
</code></pre>
<h3><a class="header" href="#ลองไปเทียบกับทีเคยเขียนไวตอนแอบเรียน" id="ลองไปเทียบกับทีเคยเขียนไวตอนแอบเรียน">ลองไปเทียบกับที่เคยเขียนไว้ตอนแอบเรียน</a></h3>
<p>ดูไปดูมา หาไปหามา จนลองไปเทียบกับไฟล์สมัยตอนแอบเรียนกับพี่ปุ๋ยก็พบว่า Test ที่เขียนไปไม่ได้อ้างอิงว่า Plus อยู่ใน package ไหน จึงทำให้เราไม่สามารถเรียกใช้ Plus ได้โดยตรง การที่เราเขียน Test โดยแยก Package ออกจาก Code ก็เพื่อที่เราจะจำลองว่า ถ้าเกิดมีใครสักคนมาเรียกใช้ Plus จาก Package อื่น ๆ เราะจะสามารถเรียกใช้ได้จริง ๆ ไหม และต้องเรียกใช้อย่างไร (การเขียนเทสคือการมองจากมุมองของลูกค้า) เพราะฉะนั้นพอลองเปลี่ยนให้ Test มีการระบุ Package และมีการ Import ที่ถูกต้อง Code ก็สามารถรันทดสอบได้ แล้วดังตัวอย่างด้านล่าง</p>
<p><code>plus.go</code></p>
<pre><code class="language-go">package calculator

func Plus(input1 int, input2 int) int {
  return input1 + input2
}
</code></pre>
<p><code>plus_test.go</code></p>
<pre><code class="language-go">package calculator_test

import (
  &quot;calculator&quot;
  &quot;testing&quot;
)

func Test1Plus1ShouldBe2Test(t *testing.T) {
  actual := calculator.Plus(1, 1)
  if 2 != actual {
    t.Errorf(&quot;1 + 1 should be 2 it's not %v&quot;, actual)
  }
}
</code></pre>
<h3><a class="header" href="#ลองไปหาขอมูลเพิมเติมมานิดหนอย" id="ลองไปหาขอมูลเพิมเติมมานิดหนอย">ลองไปหาข้อมูลเพิ่มเติมมานิดหน่อย</a></h3>
<p>จากปัญหาที่ผมเจอ ตอนที่ผมยังมึน ๆ เอาหัวมุด Code เล็ก ๆ ของผมนั้น ผมได้ลองหาข้อมูลดูว่าจริง ๆ แล้วชาวบ้านเขาเจอปัญหาแบบเดียวกันกับผม บ้างหรือเปล่า แล้วปัญหาที่เจอเขาคิดยังไง หรือแก้ยังไง จนไปเจอข้อมูลนึงใน Stack Overflow ซึ่งอ่านแล้วน่าสนใจ ใครอยากได้ข้อมูลเพิ่มสามารถไปที่นี่ได้เลยครับ</p>
<p><a href="https://sck.pub/sof-golang-test-package-name">Proper package naming for testing with the Go language - Stack Overflow</a></p>
<p>โดยคำถามนี้ถูกถามไว้เมื่อตั้งแต่ 7 ปีที่แล้ว แต่ผมก็ยังคิดว่าคำตอบของคำถามนั้นน่าสนใจมาก เพราะคนที่ถามอยากรู้ว่าวิธีการกำหนดชื่อของ Package Test ของ Go ควรจะเป็นอย่างไร โดยที่คนถาม ระบุว่าในมุมมองของเขา เขาได้ลองทำมาและเจอความเป็นไปได้ 3 แบบ ในการกำหนด Package ของ Test ใน Go คือ</p>
<ol>
<li>ใช้ชื่อ Package เดียวกันเลย (แบบที่กูลองเลย)</li>
<li>ใช้ชื่อ Package แบบที่เราคุยกันมาคือ มีคำว่า _test ต่อท้ายชื่อ Package แต่การอ้างถึงเพื่อทำการทดสอบจาก Package Test คือใช้ &quot;github.com/user/myfunc&quot; ซึ่งหมายถึงการอ้างไปถึง Package แบบ Full Path ตาม Path ของ Source ที่อยู่ใน Github เลย (อ่าอันนี้ไม่ได้ลอง)</li>
<li>ใช้ชื่อ Package ต่อท้ายด้วย คำว่า _test แต่กรณีที่คุณต้องการอ้างถึง Code ก็ใช้ Import &quot;myfunc&quot;ปกติคล้ายกับที่ผมแก้ไปก่อนหน้านี้เลย แต่ในแบบที่ 3 ของคำถาม เขา Alias ชื่อของ Package ให้เป็น “.” ทำให้สามารถเรียกใช้ฟังก์ชั่นได้เลยโดยไม่ต้องกำหนด Package <code>ซึ่งส่วนตัวผมไม่ค่อยชอบมันเท่าไหร่เพราะ ถ้าเราทำแบบนี้ใน Code เวลาที่เรากลับมาอ่าน มันทำให้เราไม่รู้ว่ามันเป็นของ Package ไหน ถึงแม้ว่าในการทดสอบเราจะใช้ Package เดียวก็เหอะ แต่ในการเขียนจริง ๆ เราก็ควรจะกำหนด Package นี่นะ (ความเห็นส่วนตัวล้วน ๆ)</code></li>
</ol>
<p><code>plus.go</code></p>
<pre><code class="language-go">package calculator

func Plus(input1 int, input2 int) int {
  return input1 + input2
}
</code></pre>
<p><code>plus_test.go</code></p>
<pre><code class="language-go">package calculator_test

import (
  . &quot;calculator&quot;
  &quot;testing&quot;
)

func Test1Plus1ShouldBe2Test(t *testing.T) {
  actual := Plus(1, 1)
  if 2 != actual {
    t.Errorf(&quot;1 + 1 should be 2 it's not %v&quot;, actual)
  }
}
</code></pre>
<h3><a class="header" href="#มันกแลวแตวาเรากำลังทดสอบแบบไหน" id="มันกแลวแตวาเรากำลังทดสอบแบบไหน">มันก็แล้วแต่ว่าเรากำลังทดสอบแบบไหน</a></h3>
<p>ที่ผมบอกว่าคำตอบมันน่าสนใจ ก็เพราะคนที่ตอบคำถามเขาบอกว่า จริง ๆ แล้วจากที่ List มาทั้ง 3 แบบ มันก็ทำให้เราสามารถทดสอบฟังก์ชันของเราได้แหละ แต่สุดท้ายการเลือกว่าจะใช้วิธีการแบบไหน มันก็ขึ้นกับความตั้งใจของเรา ว่าเรากำลังจะทดสอบมันจากมุมมองไหน โดยเขาแบ่งมุมมองของการทดสอบออกเป็น 2 ระดับ นั่นก็คือการทดสอบแบบ White-Box และ การทดสอบแบบ Black-Box ซึ่งเราสามารถทำการทดสอบได้ทั้ง แบบ โดยอาจจะสร้างเป็น plus_white_box_test.go และ plus_black_box_test.go เพื่อรองรับ การทดสอบทั้ง 2 แบบตามลำดับข้างต้น</p>
<ul>
<li>การทดสอบแบบ Black-Box —ใช้ Package ที่ชื่อ “calculator_test” เพื่อให้เรามั่นใจว่า การทดสอบนี้จะใช้ได้กับฟังก์ชั่นที่คุณ Export ออกมาให้คนอื่นใช้เท่านั้น ถ้าเผลอไปเรียกใช้ตัวที่ไม่ได้ Export ออกมามันก็จะ Compile ไม่ผ่าน (อ่านเพิ่มเรื่องการ Export)</li>
<li>การทดสอบแบบ White-Box — ใช้ Package ที่ชื่อ “calculator” เพื่อให้เราสามารถทดสอบในฟังก์ชัน ตัวแปร หรือ Method ที่ไม่ได้ Export มาให้ใช้ เพราะบางครั้งการทดสอบแบบ Unit Test ก็ต้องการที่จะ Access ไปยังของเหล่านั้น เพื่อจะได้ทดสอบเฉพาะจุดที่สนใจจริง ๆ</li>
</ul>
<p>ซึ่งเมื่อเทียบกับความเป็นไปได้ 3 อย่างในคำถามก็สามารถตอบได้ดังนี้</p>
<ol>
<li>ใช้ชื่อ Package เดียวกันเลย — อันนี้ก็ตรงตัวคือถ้าต้องการทดสอบแบบ White-Box ก็ทำแบบนี้ได้</li>
<li>ใช้ชื่อ Package แบบ Full Path ตาม Path ของ Source ที่อยู่ใน Github — อันนี้ก็มองเป็น Black-Box แต่จะมองว่า “เป็นการทดสอบโดย ทดสอบว่าถ้าแยก Package กัน Build/Deploy เลย จะสามารถดึงของจาก Package ที่แยกกันไว้ จาก Test หลักของอีก Package ได้ไหม”</li>
<li>ใช้ชื่อ Package ต่อท้ายด้วย คำว่า _test — อันนี้เหมือนอันที่ 2 แต่ใช้ Alias ระบุเป็น “.” เท่านั้นเอง</li>
</ol>
<p>ซึ่งจริง ๆ ผมยังมองไม่ออกว่าทำไมว่า ความเป็นไปได้ที่ 2 นั้นทำเพราะวัตถุประสงค์อะไร เพราะถ้าเป็นผม คงไม่แยก Code กับ Test ออกเป็นคนละ Repository แน่ ๆ แล้วถ้าจะเขียน Test เพื่อทดสอบ Code ที่เป็น Library ก็คงเขียนเพื่อทำความเข้าใจ และไม่ได้จะเก็บเทสนั้นไว้ใน Repository ของเรา</p>
<h3><a class="header" href="#มันกจะขัด-ๆ-กับทีเคยทำมาบางอะนะ" id="มันกจะขัด-ๆ-กับทีเคยทำมาบางอะนะ">มันก็จะขัด ๆ กับที่เคยทำมาบ้างอะนะ</a></h3>
<p>มาถึงตรงนี้ผมก็พอจะเข้าใจเรื่อง Package ของ Go ขึ้นมาบ้างแล้ว ยิ่งเป็นเรื่องการทดสอบแล้วด้วย ผมก็หวังเล็ก ๆ ว่าผมคงไม่ตกหลุมเดิมอีก เพียงแต่ว่า ผมเองมาจากสาย Java ซึ่งตอนสมัยที่ผมเริ่มศึกษาเรื่อง Unit Test ของ Java ก็มีคำถามนึงที่ผมค้างคาใจอยู่นานมาก คือ เราจะทำการทดสอบ Method ที่เป็น Private ได้ยังไง (Private Method ใน Java จะไม่สามารถเรียกใช้ได้จากภายนอกเลย) ซึ่งตอนนั้นก็เคยหลงทางถึงขนาดพยายามจะเปลี่ยนมันให้กลายเป็นแบบอื่น เพื่อให้ทดสอบได้ (เช่น เปลี่ยนเป็น Default หรือ Public คิดแล้วก็ปวดใจเล็ก ๆ ที่ทำไปตอนนั้น)</p>
<p>ซึ่งหลังจากที่ได้ศึกษา Unit Test บน Java มาสักระยะนึงจึงทำให้ไปเจอคำพูดที่ว่า “เราไม่ทำการทดสอบ Private Method นะ เราทดสอบมันผ่าน Method ที่เป็น Public ตามมุมมองของผู้ใช้งาน” (ประมาณนี้แหละ จำไม่ได้หล่ะ) พอมาเจอแบบที่สามารถทดสอบฟังก์ชัน ที่ไม่ได้ Export ให้คนอื่นมาเรียกใช้ได้ แบบนี้ ก็เลยรู้สึกแปลก ๆ อยูบ้าง แต่อาจจะเป็นเพราะผมยังไม่เข้าใจที่มาที่ไปของการออกแบบภาษาแบบนี้ก็เป็นได้ ยังไงถ้าได้เจออะไร Update ไว้จะมาเล่าให้ฟังอีกทีแล้วกันนะฮะ</p>
<h2><a class="header" href="#reference-1" id="reference-1">Reference</a></h2>
<ul>
<li><a href="https://ieftimov.com/post/testing-in-go-naming-conventions/">Testing in Go: Naming Conventions</a></li>
<li><a href="https://stackoverflow.com/questions/19998250/proper-package-naming-for-testing-with-the-go-language/31443271#31443271">Proper package naming for testing with the Go language</a></li>
</ul>
<h1><a class="header" href="#benchmarking" id="benchmarking">Benchmarking</a></h1>
<h2><a class="header" href="#การรัน-benchmark-เพือเทียบประสิทธิภาพของfunction" id="การรัน-benchmark-เพือเทียบประสิทธิภาพของfunction">การรัน Benchmark เพื่อเทียบประสิทธิภาพของFunction</a></h2>
<p>เราสามารถเปรียบเทียบความเร็วในการทำงานของ App ได้ด้วยการเขียน Benchmark แล้วรัน</p>
<p>ตย. เขียน Benchmark ใน test file demo_test.go</p>
<pre><code class="language-go">func BenchmarkHello(b *testing.B) {
    for i := 0; i &lt; b.N; i++ {
        demo.Greeting()
    }
}

func BenchmarkHello2(b *testing.B) {
    for i := 0; i &lt; b.N; i++ {
        demo.Greeting2()
    }
}
</code></pre>
<p>แล้วรันผ่านคำสั่ง</p>
<pre><code class="language-cmd">$go test -bench .
goos: darwin            // บอกว่าใช้  OS อะไร darwin = macOS
goarch: amd64           // บอก CPU
pkg: demo
BenchmarkHello-4        1000000000             0.347 ns/op      // บอกว่ารันใช้เวลาเท่าไหร่ต่อ 1 Operation
BenchmarkHello2-4       1000000000             0.366 ns/op
PASS
ok      demo    1.288s
</code></pre>
<h2><a class="header" href="#reference-2" id="reference-2">Reference</a></h2>
<ul>
<li><a href="https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go">How to write benchmarks in Go</a></li>
<li><a href="https://www.somkiat.cc/benchmark-in-golang/">มาใช้งาน Benchmark ในภาษา Go กัน</a></li>
</ul>
<h1><a class="header" href="#profiling" id="profiling">Profiling</a></h1>
<h2><a class="header" href="#reference-3" id="reference-3">Reference</a></h2>
<ul>
<li><a href="https://medium.com/@felipedutratine/profile-your-benchmark-with-pprof-fb7070ee1a94">Profile your golang benchmark with pprof</a></li>
<li><a href="https://gist.github.com/arsham/bbc93990d8e5c9b54128a3d88901ab90">gist of arsham/go_cpu_memory_profiling_benchmarks.sh</a></li>
</ul>
<h1><a class="header" href="#sub-testing-and-sub-benchmarking" id="sub-testing-and-sub-benchmarking">Sub Testing and Sub Benchmarking</a></h1>
<h2><a class="header" href="#reference-4" id="reference-4">Reference</a></h2>
<ul>
<li><a href="https://blog.golang.org/subtests">Using Subtests and Sub-benchmarks</a></li>
</ul>
<h1><a class="header" href="#go-type" id="go-type">Go Type</a></h1>
<h2><a class="header" href="#alias-type" id="alias-type">Alias TYPE</a></h2>
<p>เราสามารถสร้าง Type ของตัวแปลใน Go ใหม่ได้ผ่าน  คำสั่ง type</p>
<pre><code class="language-go">    type MONTH int  // สร้าง type ใหม่ที่ชื่อว่า MONTH โดยอ้างอิงจาก int

    var january MONTH // สร้างตัวแปลชื่อ january เป็นประเภท MONTH
</code></pre>
<h2><a class="header" href="#example-of-error" id="example-of-error">Example of Error</a></h2>
<p>เนื่องจาก Go เป็นภาษาที่ return type ของ function สามารถทำได้มากกว่า 1 ตัวแปร เช่น เราอาจจะอยากสร้าง function ที่ return int และ string ไปพร้อมกัน ก็ได้ และสิ่งที่ Go ไม่มีคือ exception เพราะฉะนั้น ถ้า function ของเราต้องรองรับกรณีที่ทำได้สำเร็จจะ return แบบนึง ถ้า error จะ return แบบนึงก็สามารถที่จะสร้าง functiom ที่ return หลาย ๆ ตัวแปลได้</p>
<pre><code class="language-go">package demo

import (
    &quot;errors&quot;
    &quot;fmt&quot;
)

// เป็น function ที่รับ int และ return int กับ error
func someShort(x int) (int, error) {

    err := errors.New(&quot;Normal error&quot;)

    // ถ้าเราเขียนแบบ short return เวลาจะส่งค่ากลับก็ใช้ return ตามด้วยลำดับของตัวแปลลตามรูปแบบที่เรากำหนดด้านบน 
    return 0, err
}

// เป็น function ที่ return int กับ error เหมือนกัน 
// ต่างกันตรงที่กำหนดชื่อตัวแปรไว้เลยว่า
// ค่าที่เป็น int จะ return ผ่านตัวแปร result และ error return ผ่าน err
func some(x int) (result int, err error) {
    
    // เราสามารถ set ค่าให้ตัวแปร err ได้
    err = errors.New(&quot;Normal error&quot;)

    // ค่าตัวแปร result, err จะถูก return กลับไป
    // ค่า result จะมีค่าเป็น 0 ตาม default ของภาษา
    return
}

func main() {

    // การรับค่า 2 ตัวแปรจาก function
    a, err := some(5)

    // การเลือกรับเฉพาะตัวแปร b จาก result โดยไม่สน err
    // ในเมื่อการประกาศตัวแปรทุกตัวใน go ต้องถูกเอาไปใช้ไม่งั้นจะ compile error ตัวไหนที่ไม่ได้ใช้จึงต้องใส่เป็น _ ไว้ก่อน 
    b, _ := some(5)
    
    // การเลือกรับเฉพาะตัวแปร err จาก result โดยไม่สน ตัวแปรแรก
    _, err2 := some(5)

}
</code></pre>
<p>คำถามคือ ถ้าเราเขียน  function ที่ return error มาด้วย เราควรจะเอา error ไว้ตำแหน่งไหน พี่ปุ๋ยเลยให้ดู ตัวอย่างจากพวก Library ที่อยู่ใน golang website ก็จะเห็นว่าเขาไว้เป็นตัวสุดท้ายเสมอเลย เพราะฉะนั้นเราจะเอาภาษาอะไรมาพัฒนา เราจำเป็นต้องแนวคิด แนวการเขียนของภาษานั้น ๆ ด้วย</p>
<h1><a class="header" href="#collection-type" id="collection-type">Collection Type</a></h1>
<h2><a class="header" href="#collection-type-in-go" id="collection-type-in-go">Collection Type in Go</a></h2>
<p>ใน Go มี Type เป็น Collection อยู่ 3 ประเภท</p>
<ul>
<li>Array :   น่าจะรู้กันอยู่ ไม่พูดเยอะ</li>
<li>Slice :   Array ที่ไม่ต้องกำหนดขนาด</li>
<li>Map :     Collection แบบ Key, Value</li>
</ul>
<h1><a class="header" href="#array" id="array">Array</a></h1>
<pre><code class="language-go">// ประกาศตัวแปรที่ชื่อว่า numbers เป็น Array ของ int ที่มีขนาดเท่ากับ 5
var numbers [5]int

// การอ้างถึง Array ทำได้ใน []
numbers[0] = 1
numbers[1] = 2

// การประกาศ Array ของ String โดยสร้างจากค่าตั้งต้นเลย
var colors = [2]string{&quot;Red&quot;, &quot;Blue&quot;}
</code></pre>
<h2><a class="header" href="#รูปแบบของ-for-loop" id="รูปแบบของ-for-loop">รูปแบบของ For Loop</a></h2>
<p>ใน Go มี Loop แค่แบบเดียวคือ Loop For เพราะฉะนั้นเวลาจะใช้ต้องไปประยุกต์เอาเอง ว่าจะใช้งานแบบไหน เช่นตัวอย่างของการเอา For Loop ไปใช้กับข้อมูลใน Array</p>
<pre><code class="language-go">// Loop จาก Len ของ Array แล้วก็อ้างถึงข้อมูลตามตำแหน่งในแต่ละรอบ
for i := 0; i &lt; len(colors); i++ {
    fmt.Println(colors[i])
}

// ใช้ Loop ร่วมกับ  range เพื่อแกะข้อมูลออกมาทีละตัว
for i, v := range colors {
    // range จะ return ค่ากลับมา 2 ตัวคือ Index และ Value  ถ้าไม่อยากได้ก็สามารถใช้  _ ได้
    fmt.Println(i, &quot; &quot;, v)
}

// infinite loop
for {

}

// for 5 loop อันนี้เอาไปประยกต์ใช้กับ while loop ได้
var i = 0
for i &lt; 5 {
    i++
    log.Printf(&quot;Logging %v&quot;, i)
}

2021/01/XX 16:41:11 Logging 1
2021/01/XX 16:41:11 Logging 2
2021/01/XX 16:41:11 Logging 3
2021/01/XX 16:41:11 Logging 4
2021/01/XX 16:41:11 Logging 5
</code></pre>
<h2><a class="header" href="#array-of-func" id="array-of-func">Array of func</a></h2>
<p><a href="https://stackoverflow.com/questions/50913022/array-of-functions-to-as-argument-in-golang">Array of functions to as argument in Golang</a></p>
<h1><a class="header" href="#slice" id="slice">Slice</a></h1>
<p>คือ Loop ที่ไม่ต้องกำหนดขนาดตอนตั้งต้น ที่เหลือเหมือน Array</p>
<pre><code class="language-go">// Array
var colors = [5]string{&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;, &quot;Yellow&quot;, &quot;Black&quot;}

// Slice
var colorSlice = []string{&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;, &quot;Yellow&quot;, &quot;Black&quot;}
</code></pre>
<p>เราสามารถสร้าง Slice ได้ด้วยคำสั่ง make พร้อมระบุขนาดเบื้องต้นได้</p>
<pre><code class="language-go">// Make
var colorMake = make([]string, 5)
</code></pre>
<p>ลอง Print ออกมาดู</p>
<pre><code class="language-go">fmt.Println(&quot;colors =     &quot;, colors)
fmt.Println(&quot;colorSlice =     &quot;, colorSlice)
fmt.Println(&quot;colorMake =     &quot;, colorMake)

colors =         [Red Blue Green Yellow Black]
colorSlice =     [Red Blue Green Yellow Black]
colorMake =      [    ]
</code></pre>
<p>เราสามารถตัดข้อมูลจาก Array มาเป็น Slice อีกตัวได้โดยระบุตำแหน่ง</p>
<pre><code class="language-go">//  เอาข้อมูลจากตำแหน่งที่ 0 ถึงตัวก่อนตำแหน่งที่ 2 
a := colors[0:2]
fmt.Println(&quot;a = &quot;, a)

[result]
a =  [Red Blue]
</code></pre>
<p>เราสามารถเพิ่มสมาชิกเข้าไปใน Slice ได้ผ่านคำสั่ง append</p>
<pre><code class="language-go">a = append(a, &quot;XXX&quot;)
fmt.Println(&quot;a = &quot;, a)

[result]
a =  [Red Blue XXX]
</code></pre>
<pre><code class="language-go">a = append(a, &quot;YYY&quot;)
fmt.Println(&quot;a = &quot;, a)

[result]
a =  [Red Blue XXX YYY]
</code></pre>
<p>คำถามที่สำคัญที่คนเขียน Go ต้องรู้คือ ถ้าเราแก้ไขข้อมูลใน Slice a (ซึ่งเกิดจาก Array colors) จะมีผลต่อข้อมูลใน Array colors ไหมนะลองแก้ตัวแรกดู</p>
<pre><code class="language-go">a[0] = &quot;New&quot;
fmt.Println(&quot;colors,a = &quot;, colors, a)

[result]
colors,a =  [New Blue XXX YYY Black] [New Blue XXX YYY]
</code></pre>
<p>จะเห็นได้ว่า Slice a ใช้ที่เก็บเดียวกันกับ Array colors เนื่องจากใช้ pointer เดียวกัน เพราะฉะนั้น</p>
<ul>
<li>ตอนที่เรา append XXX เข้าไปต่อท้าย a ข้อมูลก็จะไปทับตัวที่อยู่ใน colors ด้วย</li>
</ul>
<pre><code class="language-text">จากที่

        |------|------|-------|--------|-------|
        | Red  | Blue | Green | Yellow | Black |
        |------|------|-------|--------|-------|
        ^                                      ^
        |               colors                 |
        
        ^             ^
        |      a      |

พอเราสั่ง append a ด้วย XXX ก็เลยกลายเป็น 

        |------|------|-------|--------|-------|
        | Red  | Blue |  XXX  | Yellow | Black |
        |------|------|-------|--------|-------|
        ^                                      ^
        |               colors                 |
        
        ^                     ^
        |          a          |

เพราะมันไปต่อจาก a เดิม ซึ่งแปลว่า colors ก็ถูกแก้ด้วย
</code></pre>
<p>เราสามารถเรียงลำดับของที่อยู่ใน Slice ได้ด้วย</p>
<pre><code class="language-go">var intSlice = []int{11, 3, 4, 1, 5, 6, 2}
sort.Ints(intSlice)   // เอา Slice มาเรียงลำดับตามตัวเลข
fmt.Println(intSlice)

var stringSlice = []string{&quot;wat&quot;, &quot;sivarat&quot;, &quot;bomb&quot;, &quot;karan&quot;}
sort.Strings(stringSlice)   // เอา Slice มาเรียงลำดับตามตัวอักษร
fmt.Println(stringSlice)

[result]
[1 2 3 4 5 6 11]
[bomb karan sivarat wat]
</code></pre>
<h1><a class="header" href="#map" id="map">Map</a></h1>
<p>Collection Type สุดท้ายใน Go คือ Map ซึ่งมันก็คือการเก็บข้อมูลเป็นคู่แบบ Key, Value ที่เราคุ้นเคยเนี่ยแหละ</p>
<pre><code class="language-go">numbers := make(map[string]int)
numbers[&quot;one&quot;] = 1
fmt.Println(&quot;Numbers =&quot;, numbers)
</code></pre>
<p>ในกรณีที่เราต้องการอ่านค่าจาก Key ก็ทำได้</p>
<pre><code class="language-go">n1 := numbers[&quot;one&quot;]
fmt.Println(&quot;n1 =&quot;, n1)

[result]
n1 = 1
</code></pre>
<p>กรณีไม่มีมันจะเอา Zero Value (คืออันเดียวกับ Default Value) มาใส่ให้</p>
<pre><code class="language-go">n2 := numbers[&quot;two&quot;]
fmt.Println(&quot;n2 =&quot;, n2)

[result]
n2 = 0
</code></pre>
<p>ซึ่งถ้าเราต้องการตรวจสอบก่อนว่ามีค่าหรือเปล่าก็สามารถเช็ค error ของ map ได้</p>
<pre><code class="language-go">if e2, found := numbers[&quot;two&quot;]; found { // ถ้าเจอ ตัวแปร found จะเป็น true
    fmt.Println(&quot;Found = &quot;, e2)
} else {
    fmt.Println(&quot;Not Found&quot;)
}

[result]
Not Found
</code></pre>
<h1><a class="header" href="#struct" id="struct">Struct</a></h1>
<p>เป็น Type ลักษณะ Object ที่สามารถกำหนดได้เองว่าภายในจะประกอบไปด้วย attribute อะไรบ้าง</p>
<h2><a class="header" href="#simple-struct" id="simple-struct">Simple struct</a></h2>
<pre><code class="language-go">type user struct {
    id   int
    name string
}

func main() {
    u1 := user{1, &quot;bomb0069&quot;}        // Go จะใส่ให้ตามลำดัับที่เรากำหนดไว้ กรณนี้ 1-&gt;id, bomb0069-&gt;name
    u2 := user{id: 2, name: &quot;karan&quot;} // ระบุชื่อเลยว่าจะเอาเข้า attribute ไหน
    u1.name = &quot;XXX&quot;                  // assign ค่าไปที่ attribute ได้
    fmt.Printf(&quot;%v&quot;, u1)
    fmt.Printf(&quot;%+v&quot;, u2)
}
</code></pre>
<p>หรือเราจะสร้าง function เพื่อ new object ก็ได้</p>
<pre><code class="language-go">func New(id int, name string) User {
    return User{1, &quot;bomb0069&quot;}
}

func main() {
    u1 := New(1, &quot;bomb0069&quot;)
    fmt.Printf(&quot;%v&quot;, u1)
}
</code></pre>
<h2><a class="header" href="#struct-with-struct-composition" id="struct-with-struct-composition">Struct with Struct Composition</a></h2>
<pre><code class="language-go">type User struct {
    Id   int
    UserForNew   // User มีการ Embeded เอา UserForNew  เข้ามาด้วย
}

type User2 struct {
    Id          int
    UserForNew  UserForNew  // User2 ประกอบไปด้วย id กับ UserForNew
}

type UserForNew struct {
    Name string
}

func New(id int, name string) User {
    return User{1, UserForNew{&quot;bomb0069&quot;}}
}

func main() {
    u1 := User{1, UserForNew{&quot;bomb0069&quot;}}
    u2 := User2{2, UserForNew{&quot;karan&quot;}}
    u3 := NewUser(&quot;bomb0069&quot;)
    u1.Name = &quot;XXX&quot;   // กรณีมีการ Embeded เราสามารถเรียกใช้ Attribute ในของที่เรา Embeded มาได้โดยตรง 
    fmt.Printf(&quot;%+v\n&quot;, u1)
    fmt.Printf(&quot;%+v\n&quot;, u1.Name) // อ้างถึงตรง
    fmt.Printf(&quot;%+v\n&quot;, u1.UserForNew.Name) // อ้่างถึงผ่าน UserForNew
    fmt.Printf(&quot;%+v\n&quot;, u2.UserForNew.Name)
    fmt.Printf(&quot;%+v\n&quot;, u3)

    fmt.Printf(&quot;%+v\n&quot;, u3.Name)
}

[result]
{Id:1 UserForNew:{Name:XXX}}  // ถึงจะเป็น Embeded เวลา print ก็ยังเห็นเหมือนมี UserForNew ครอบอยู่
XXX
XXX
karan
{Id:1 UserForNew:{Name:bomb0069}}
bomb0069
</code></pre>
<h2><a class="header" href="#method-in-struct" id="method-in-struct">Method in Struct</a></h2>
<p>เนื่องจาก Go ไม่ใช่ Object Oriented เพราะถึงมี Struct แต่ก็มีแค่ Attribute ไม่มี Behavior หรือ Method แต่เราสามารสร้าง function ไปผูกกับ struct เพื่อทำหน้าที่คล้าย method ของ OOP ได้</p>
<pre><code class="language-go">type User struct {
    Id int
    Name string
}

// ประกาศว่า function นี้มี receiver type (หมายถึง struct ที่จะเอาไปผูกแล้วส่งมาเมื่อถูกเรียก) คือ User
func (user User) printName() {
    fmt.Println(&quot;User := &quot;, user.Name)
}

func main() {
    u := User{2, &quot;karan&quot;}
    // สามารถเอา u ที่เกิดจาก User มาเรียกใช้ printName ได้
    u.printName()
}
</code></pre>
<h2><a class="header" href="#method-of-struct-and-overwrite-method-in-go-for-embeded" id="method-of-struct-and-overwrite-method-in-go-for-embeded">Method of Struct and Overwrite Method in Go (for embeded)</a></h2>
<pre><code class="language-go">type User struct {
    Name string
}

type User2 struct {
    Id int
    User
}

func (user User) printName() {
    fmt.Println(&quot;User := &quot;, user.Name)
}

func (user User2) printName() {
    fmt.Println(&quot;User 2 := &quot;, user.Name)  // User2 สามารถเรียกใช้ Name ใน User ได้โดยตรงเพราะเป็น Embeded
}

func main() {
    u2 := User2{2, User{&quot;karan&quot;}}
    u2.printName()

}

[result]
User 2 :=  karan
</code></pre>
<h2><a class="header" href="#method-of-struct-with-pointer" id="method-of-struct-with-pointer">Method of Struct with Pointer</a></h2>
<p>Method ก่อนหน้านี้เป็นแค่ action ที่ทำผ่าน struct เท่านั้นไม่สามารถ เปลี่ยนแปลงค่าที่อยู่ใน Struct ได้ ลองดู Code ข้างล่างนี้</p>
<pre><code class="language-go">type User struct {
    Id   int
    Name string
}

func (user User) sleep() {
    user.Name = &quot;XXXXX&quot;   // มีการ Set ค่า Name เป็น XXXXX
}

func main() {
    u := User{2, &quot;karan&quot;}
    u.sleep()              // sleep เปลี่ยนค่า Name เป็น XXXXX
    fmt.Println(u.Name)    // print ค่า Name ออกมา
}

[result]
karan                      // ผลออกมาค่าไม่เปลี่ยน ยังเป็น karan เหมือนตอน New
</code></pre>
<p>เนื่องจาก receiver type ของ function sleep ส่ง User มาเป็น value ทำให้การเปลี่ยนแปลงภายในไม่มีผลกับภายนอก แก้โดยเพิ่ม * ไปตรง receiver type และ &amp; ไปตอน new object (อันหลังผมไม่ใส่ก็ยังใช้ได้ แต่พี่ปุ๋ยบอกว่าให้ใส่เพื่อเราจะได้รู้ว่าเราจะเอาไปใช้แบบไหน)</p>
<pre><code class="language-go">type User struct {
    Id   int
    Name string
}

func (user *User) sleep() {  // เพิ่ม * หน้า User เพื่อบอกว่าเป็น pointer
    user.Name = &quot;XXXXX&quot;
}

func main() {
    u := User{2, &quot;karan&quot;}     // สร้าง user แบบปกติ
    u.sleep()
    fmt.Println(&quot;User := &quot; + u.Name)

    u2 := &amp;User{2, &quot;karan&quot;}   // สร้าง user แบบมี &amp; ด้านหน้า
    u2.sleep()
    fmt.Println(&quot;User2 :=&quot; + u2.Name)
}

[result]
User := XXXXX   // ผลออกเหมือนกัน
User2 := XXXXX
</code></pre>
<h1><a class="header" href="#error-and-defer" id="error-and-defer">Error and Defer</a></h1>
<p>เนื่องจากใน Go ไม่มี exception เพราะฉะนั้นในกรณีที่เกิดปัญหาตอน runtime แล้วต้องการ Handle case ที่เกิดขึ้น เช่น ต้องปิด connection Database ถึงแม้ว่าจะเกิด Run Time Error ก็ตาม เราสามารถทำได้โดยการสร้าง Function ที่จะทำงานทุกครั้ง เมื่อ Function หลักของเราทำงานเสร็จ แล้วเช็คว่าเกิด panic ขึ้นได้ ผ่าน recover function</p>
<pre><code class="language-go">func main() {

    deferAtEnd()

    deferWhenError()

}

func deferAtEnd() {
    fmt.Println(&quot;deferAtEnd - Start&quot;)
    // ประกาศว่าให้ เรียก panicHandler หลังจบการทำงานของ function ส่วนใหญ่เขียนไว้เพื่อ Close Resource ที่ร้องไว้ เมื่อทำงานเสร็จ
    defer panicHandler()
    fmt.Println(&quot;deferAtEnd - After defer panicHandler&quot;)

    fmt.Println(&quot;deferAtEnd - doSomething&quot;)

    fmt.Println(&quot;deferAtEnd - Start&quot;)
}

func deferWhenError() {
    fmt.Println(&quot;deferWhenError - Start&quot;)
    defer panicHandler()
    fmt.Println(&quot;deferWhenError - After defer panicHandler&quot;)

    b, err := ioutil.ReadFile(&quot;try_panic.go&quot;)
    fmt.Println(&quot;deferWhenError - After readfile&quot;)
    if err != nil {
        fmt.Println(&quot;deferWhenError - before panic&quot;)
        // call function panic เพื่อบอกว่าเกิด error ณ runtime
        panic(&quot;some error&quot;)
        fmt.Println(&quot;deferWhenError - after panic&quot;)
    }
    // จาก code จะเกิด panic และไม่เข้ามาทำงานในส่วนนี้
    fmt.Println(string(b))
    fmt.Println(&quot;deferAtEnd - After doSomething&quot;)

    fmt.Println(&quot;deferWhenError - Start&quot;)
}

// function ที่จะ Handle ทุกครั้งที่ deferAtEnd และ deferWithError ทำงานเสร็จ
func panicHandler() {
    // อ่าน error จาก function recover
    err := recover()
    // เช็คว่ามี panic ไหมโดยดุจาก err ถ้าไม่เกิด panic ก็ไม่เข้าใน if
    if err == &quot;some error&quot; {
        fmt.Println(&quot;panicHandler - Try to recover from panic&quot;)
    }
    fmt.Println(&quot;panicHandler - Do it at the end&quot;)    
}
</code></pre>
<p>เพราะฉะนั้น</p>
<pre><code class="language-text">Error is for application error, Defer for run time and need to recover state
</code></pre>
<h1><a class="header" href="#day-2" id="day-2">Day 2</a></h1>
<h2><a class="header" href="#review-homework" id="review-homework">Review Homework</a></h2>
<h3><a class="header" href="#file-permission" id="file-permission">File Permission</a></h3>
<p>0644
0755</p>
<h3><a class="header" href="#folder-structure-for-entity" id="folder-structure-for-entity">Folder Structure for Entity</a></h3>
<p>user.go and entity/user.go are you confuse which file are you change</p>
<h3><a class="header" href="#ทิศทางของ-code-func-ใน-struc" id="ทิศทางของ-code-func-ใน-struc">ทิศทางของ Code func ใน struc</a></h3>
<p>func (cli Cli) AddUser</p>
<p>func (cli *Cli) PrintUser</p>
<h3><a class="header" href="#golang-ไมมี-case-type-มีแต-convert-type" id="golang-ไมมี-case-type-มีแต-convert-type">Golang ไม่มี Case Type มีแต่ Convert Type</a></h3>
<pre><code class="language-go">var users []byte
users = []byte(&quot;[]&quot;)  // convert string to byte array
</code></pre>
<h3><a class="header" href="#hardcode-vs-initial-parameter" id="hardcode-vs-initial-parameter">Hardcode vs Initial Parameter</a></h3>
<p>รอดูพี่ปุ๋ยพาทำ</p>
<pre><code class="language-go">var storage := Store (Path: &quot;static/db.json&quot;)
</code></pre>
<h3><a class="header" href="#เอา-interface-มากัน-การทำงานของ-service-ทีเปน-store" id="เอา-interface-มากัน-การทำงานของ-service-ทีเปน-store">เอา Interface มากั้น การทำงานของ Service ที่เป็น Store</a></h3>
<p><a href="https://github.com/up1/workshop-golang-20210116/tree/main/workshop-cli">Example Code</a></p>
<pre><code class="language-go">func main() {
  // Initial dependencies
  store := cli.FileStore{Filename: &quot;demo.json&quot;}
  userService := cli.UserService{Store: &amp;store}

  // Parser input from command line
  command := os.Args[1]
  switch command {
  case &quot;add&quot;:
    name := os.Args[2]
    age := os.Args[3]
    iage, _ := strconv.Atoi(age)
    userService.AddNew(name, iage)
  case &quot;list&quot;:
    res := userService.ListAll()
    fmt.Println(res)
  }
}
</code></pre>
<h3><a class="header" href="#demo-package-for-subpackagesubmodule" id="demo-package-for-subpackagesubmodule">Demo Package for SubPackage/SubModule</a></h3>
<pre><code class="language-cmd">mkdir demo_package
cd demo_package

go mod init sample

touch sample.go
</code></pre>
<p>create sub packag section 1</p>
<pre><code class="language-cmd">mkdir section1
cd section1

touch user.go
</code></pre>
<p>**** อย่าทำนะ  import &quot;../sample/section1&quot; อันนี้แปลว่าไม่เข้าใจ</p>
<p>**** การทำงานข้าม Package จำเป็นต้องเอา Interface มากั้นไหม ดูความเหมาะสม Standard ส่วนใหญ่เขาเอามากั้น แต่ถ้าเราใช้ภายในกันเองก็อาจจะไม่จำเป็นเพราะ เรื่องความซับซ้อน</p>
<h3><a class="header" href="#update-version-of-library" id="update-version-of-library">Update Version of Library</a></h3>
<p>อยู่ใน go.mod ไม่ควรแก้ไขเอง
ลบใน go.mod เลยก็ได้ เดี๋ยวมันก็เอาของใหม่มา</p>
<p>เวลาที่เราเอา import package ออกจาก Code มันจะยังไม่ clear ออกจาก go.mod ต้องเคลียร์เอง</p>
<pre><code class="language-cmd">go mod tidy // clear package  ที่ไม่ได้ใช้งาน
</code></pre>
<p>อ่านเพิ่ม
<a href="https://golang.org/doc/code.html">How to Write Go Code</a></p>
<p>ที่อยู่ของ Library ที่เราเอามาลงไว้ที่เครื่องจะอยู่ใน</p>
<p>${GOPATH}/pkg/mod</p>
<h3><a class="header" href="#golang-is-test-by-default-นะครับ" id="golang-is-test-by-default-นะครับ">GoLang is test by Default นะครับ</a></h3>
<p>คนเขียนภาษา Go ยังเขียน Test เลย เราเป็นใคร เอา Go มาใช้แล้วไม่เขียน Test</p>
<h2><a class="header" href="#go-project-structure" id="go-project-structure">Go project structure</a></h2>
<h3><a class="header" href="#flat" id="flat">Flat</a></h3>
<p>handler.go ทำงานหลังจาก route.go เพื่อ handle กรณีที่ส่งต่อไป package อื่น ๆ</p>
<p>route.go ก็ไม่ควรยาว ๆ แล้วให้มีแยก route ย่อยออกไป</p>
<h3><a class="header" href="#layer" id="layer">Layer</a></h3>
<p>แต่ถ้าเยอะแล้วกระโดดไปมาหรือเปล่า แล้วก็มาต้องการ IDE แบบที่ Link ไปมาได้เพราะมันเยอะมาก หายากมาก เปิดไฟล์เต็มไปหมด</p>
<h3><a class="header" href="#modular" id="modular">Modular</a></h3>
<p>แยกตามกลุ่ม Business เลย แยก Sub Module เป็นเรื่อง ๆ ตามกลุ่มการทำงาน เวลาที่เราต้องแก้อะไร เราก็จะสามารเข้าไปหามันได้เลย</p>
<p>เวลาที่ Package มันเริ่มใหญ่ขึ้น เราก็สามารถแยกไปเป็น Repo ใหม่ได้เลยนะ</p>
<h3><a class="header" href="#clean-architecture-and-hexagonal-architecture" id="clean-architecture-and-hexagonal-architecture">Clean Architecture and Hexagonal architecture</a></h3>
<p>มันแยกหน้าที่ได้ เห็นชัด แต่ต้องระวัง เดี๋ยวจะไปเจอ Pattern แถมจะไปเจอพวก cli สำหรับการ generate code ต้องระวัง คำถามคือแต่ละเรื่องจำเป็นต้องมีไหม</p>
<h2><a class="header" href="#building-rest-apis" id="building-rest-apis">Building REST APIs</a></h2>
<h3><a class="header" href="#nethttp" id="nethttp">net/http</a></h3>
<pre><code class="language-go">func main() {
  http.HandleFunc(&quot;/&quot;, Response)
  http.HandleFunc(&quot;/users&quot;, UserHandler)
  http.ListenAndServe(&quot;:8080&quot;, nil)
}

func HandleFunc(pattern string, handler func(ResponseWriter, *Request))
</code></pre>
<h4><a class="header" href="#func-return-func" id="func-return-func">Func return func</a></h4>
<pre><code class="language-go">func Aaa(int a) func(int) int {
    // Func Aaa จะ Return เป็น Function ที่รับ int และ return int
}
</code></pre>
<h4><a class="header" href="#marshallunmarshall-vs-encoderdecoder" id="marshallunmarshall-vs-encoderdecoder">Marshall/Unmarshall vs Encoder/Decoder</a></h4>
<p>มี 2 วิธีในการ แปลง json ต้องไปลองเองว่าอะไรดี กว่า ดีสุดก็เขียนแล้วรันเทียบดู</p>
<pre><code class="language-go">json.NewEncoder(w).Encode(u)
</code></pre>
<h4><a class="header" href="#ยิง-performance-test" id="ยิง-performance-test">ยิง Performance Test</a></h4>
<pre><code class="language-cmd">wrk -c 100 -t 5 -d http://localhost:8080
</code></pre>
<h3><a class="header" href="#echo" id="echo">Echo</a></h3>
<pre><code class="language-go">
func main() {
  e := echo.New()
  e.GET(&quot;/&quot;, hello)
  e.GET(&quot;/users&quot;, getUser)
  e.Logger.Fatal(e.Start(&quot;:8080&quot;))
}

func hello(c echo.Context) error {
  return c.JSON(http.StatusOK, &quot;Hello world&quot;)
}
</code></pre>
<h3><a class="header" href="#gin" id="gin">Gin</a></h3>
<pre><code class="language-go">func hello(c *gin.Context) {
  c.JSON(http.StatusOK, &quot;Hello world&quot;)
}

func main() {
  r := gin.Default()
  r.GET(&quot;/&quot;, hello)
  r.GET(&quot;/users&quot;, getUsers)
  r.Run(&quot;:8080&quot;)
}
</code></pre>
<pre><code class="language-cmd">% go run . 
go: downloading github.com/gin-gonic/gin v1.6.3
go: downloading github.com/go-playground/validator/v10 v10.2.0
go: downloading github.com/golang/protobuf v1.3.3
go: downloading golang.org/x/sys v0.0.0-20200116001909-b77594299b42
[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.

[GIN-debug] [WARNING] Running in &quot;debug&quot; mode. Switch to &quot;release&quot; mode in production.
 - using env:  export GIN_MODE=release
 - using code:  gin.SetMode(gin.ReleaseMode)

[GIN-debug] GET    /                         --&gt; main.hello (3 handlers)
[GIN-debug] GET    /users                    --&gt; main.getUsers (3 handlers)
[GIN-debug] Listening and serving HTTP on :8080
</code></pre>
<h4><a class="header" href="#using-env--export-gin_moderelease" id="using-env--export-gin_moderelease">using env:  export GIN_MODE=release</a></h4>
<h4><a class="header" href="#close-log-mode" id="close-log-mode">Close log mode</a></h4>
<h3><a class="header" href="#a-hrefhttpsgithubcomgofiberfiberfibera" id="a-hrefhttpsgithubcomgofiberfiberfibera"><a href="https://github.com/gofiber/fiber">Fiber</a></a></h3>
<p>เร็วกว่ามาก ข้างในใช้ <a href="https://github.com/valyala/fasthttp">fasthttp</a></p>
<pre><code class="language-go">func hello(c *fiber.Ctx) error {
  return c.JSON(&quot;Hello world&quot;)
}

func main() {
  app := fiber.New()
  app.Get(&quot;/&quot;, hello)
  app.Get(&quot;/users&quot;, getUsers)
  app.Listen(&quot;:8080&quot;)
}
</code></pre>
<h3><a class="header" href="#สรุป" id="สรุป">สรุป</a></h3>
<p>วิธีการคล้ายกัน แต่ต้องดูว่าเราชอบแบบไหน และ community มีคนใช้กันเยอะไหม แต่ดีที่สุดคือ POC ในหลาย ๆ ด้าน และเลือกให้เหมาะกับงาน</p>
<h2><a class="header" href="#a-hrefhttpsgithubcomup1workshop-golang-20210116treemainworkshop-gin-mongodbworkshopa" id="a-hrefhttpsgithubcomup1workshop-golang-20210116treemainworkshop-gin-mongodbworkshopa"><a href="https://github.com/up1/workshop-golang-20210116/tree/main/workshop-gin-mongodb">Workshop</a></a></h2>
<h3><a class="header" href="#structure" id="structure">Structure</a></h3>
<p>main -&gt; user -&gt; db -&gt; mongo</p>
<h3><a class="header" href="#การทำงานของ-router-และ-middlewares" id="การทำงานของ-router-และ-middlewares">การทำงานของ Router และ Middlewares</a></h3>
<h3><a class="header" href="#การทำ-resource-และ-inject-ไปใชใน-repository" id="การทำ-resource-และ-inject-ไปใชใน-repository">การทำ Resource และ Inject ไปใช้ใน Repository</a></h3>
<ul>
<li>
<p>การทำ Inject DB Resource</p>
</li>
<li>
<p>การทำ Resource ตรงกลางให้เขามาเรียกใช้ แล้วคืนตอนหลัง เช่นไปใช้ MongoBetween</p>
</li>
</ul>
<h3><a class="header" href="#การแยก-implementation" id="การแยก-implementation">การแยก Implementation</a></h3>
<p>ระหว่าง User ที่ใช้ Route ของ GIN อยู่ ไปใช้ อย่างอื่น ก็ต้องตัด Dependency ผ่าน Interface ที่เราต้องการ</p>
<h2><a class="header" href="#link" id="link">Link</a></h2>
<ul>
<li><a href="https://github.com/swaggo/gin-swagger"></a></li>
<li><a href="https://echo.labstack.com/cookbook/graceful-shutdown"></a></li>
<li><a href="https://github.com/wg/wrk"></a></li>
<li><a href="https://github.com/tsliwowicz/go-wrk"></a></li>
<li><a href="https://echo.labstack.com/"></a></li>
<li><a href="https://github.com/gin-gonic/gin"></a></li>
<li><a href="https://github.com/gofiber/fiber"></a></li>
<li><a href="https://github.com/valyala/fasthttp/pulse"></a></li>
<li><a href="https://github.com/coinbase/mongobetween"></a></li>
<li><a href="https://echo.labstack.com/guide/routing"></a></li>
</ul>
<h1><a class="header" href="#system" id="system">System</a></h1>
<h2><a class="header" href="#reference-5" id="reference-5">Reference</a></h2>
<ul>
<li><a href="https://stackoverflow.com/questions/7052693/how-to-get-the-name-of-a-function-in-go">How to get the name of a function in Go?</a></li>
<li><a href="https://golang.org/pkg/time/#Sleep">Time Package</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
